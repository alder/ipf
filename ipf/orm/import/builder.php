<?php

class IPF_ORM_Import_Builder
{
    private $_baseClassPrefix = 'Base';
    private $_baseClassesDirectory = IPF_ORM::BASE_CLASSES_DIRECTORY;

    private static function varExport($var)
    {
        $export = var_export($var, true);
        $export = preg_replace('#\s*\(\s*#', '(', $export);
        $export = preg_replace('#[\s,]+\)#', ')', $export);
        $export = preg_replace('#\s+#', ' ', $export);
        return $export;
    }

    private function buildTableDefinition(array $definition)
    {
        if (isset($definition['inheritance']['type']) && ($definition['inheritance']['type'] == 'simple' || $definition['inheritance']['type'] == 'column_aggregation')) {
            return;
        }

        $ret = array(
            '  public function setTableDefinition()',
            '  {',
            '    $table = $this->getTable();',
        );

        if (isset($definition['inheritance']['type']) && $definition['inheritance']['type'] == 'concrete')
            $ret[] = "    parent::setTableDefinition();";

        if (isset($definition['tableName']) && !empty($definition['tableName']))
            $ret[] = "    ".'$table->setTableName(\''. $definition['tableName'].'\');';

        if (isset($definition['columns']) && is_array($definition['columns']) && !empty($definition['columns']))
            $ret[] = $this->buildColumns($definition['columns']);

        if (isset($definition['indexes']) && is_array($definition['indexes']) && !empty($definition['indexes']))
            foreach ($definition['indexes'] as $indexName => $definitions)
                $ret[] = "    \$table->addIndex('" . $indexName . "', " . self::varExport($definitions) . ');';

        if (isset($definition['attributes']) && is_array($definition['attributes']) && !empty($definition['attributes']))
            $ret[] = $this->buildAttributes($definition['attributes']);

        if (isset($definition['options']) && is_array($definition['options']) && !empty($definition['options']))
            $ret[] = $this->buildOptions($definition['options']);

        if (isset($definition['inheritance']['subclasses']) && !empty($definition['inheritance']['subclasses'])) {
            $ret[] = "    ".'$table->setSubClasses('. self::varExport($definition['inheritance']['subclasses']).');';
        }

        $ret[] = '  }';

        return implode(PHP_EOL, $ret);
    }

    private function buildSetUp(array $definition)
    {
        $ret = array();

        if (isset($definition['relations']) && is_array($definition['relations']) && !empty($definition['relations'])) {
            foreach ($definition['relations'] as $name => $relation) {
                $class = isset($relation['class']) ? $relation['class'] : $name;
                $alias = (isset($relation['alias']) && $relation['alias'] !== $relation['class']) ? $relation['alias'] : '';

                if (!isset($relation['type']))
                    $relation['type'] = IPF_ORM_Relation::ONE;

                if ($relation['type'] === IPF_ORM_Relation::ONE ||
                    $relation['type'] === IPF_ORM_Relation::ONE_COMPOSITE) {
                    $r = "    \$table->hasOne('$class', '$alias'";
                } else {
                    $r = "    \$table->hasMany('$class', '$alias'";
                }

                $a = array();

                if (isset($relation['refClass'])) {
                    $a[] = '\'refClass\' => ' . self::varExport($relation['refClass']);
                }

                if (isset($relation['deferred']) && $relation['deferred']) {
                    $a[] = '\'default\' => ' . self::varExport($relation['deferred']);
                }

                if (isset($relation['local']) && $relation['local']) {
                    $a[] = '\'local\' => ' . self::varExport($relation['local']);
                }

                if (isset($relation['foreign']) && $relation['foreign']) {
                    $a[] = '\'foreign\' => ' . self::varExport($relation['foreign']);
                }

                if (isset($relation['onDelete']) && $relation['onDelete']) {
                    $a[] = '\'onDelete\' => ' . self::varExport($relation['onDelete']);
                }

                if (isset($relation['onUpdate']) && $relation['onUpdate']) {
                    $a[] = '\'onUpdate\' => ' . self::varExport($relation['onUpdate']);
                }

                if (isset($relation['equal']) && $relation['equal']) {
                    $a[] = '\'equal\' => ' . self::varExport($relation['equal']);
                }

                if (isset($relation['owningSide']) && $relation['owningSide']) {
                    $a[] = '\'owningSide\' => ' . self::varExport($relation['owningSide']);
                }

                if (isset($relation['exclude']) && $relation['exclude']) {
                    $a[] = '\'exclude\' => ' . self::varExport($relation['exclude']);
                }

                if (!empty($a))
                    $r .= ', array(' . implode(', ', $a) . ')';

                $ret[] = $r.');';
            }
        }

        if (isset($definition['templates']) && is_array($definition['templates']) && !empty($definition['templates'])) {
            $this->buildTemplates($definition['templates'], $ret);
        }

        if (isset($definition['actAs']) && is_array($definition['actAs']) && !empty($definition['actAs'])) {
            $this->buildActAs($definition['actAs'], $ret);
        }

        if (isset($definition['listeners']) && is_array($definition['listeners']) && !empty($definition['listeners'])) {
            foreach ($definition['listeners'] as $listener) {
                $ret[] = "    \$table->listeners['$listener'] = new $listener;";
            }
        }

        // If the body of the function has contents and we are using inheritance
        // then we need call the parent::setUp() before the body of the function
        // Class table inheritance is the only one we shouldn't call parent::setUp() for
        if (count($ret) && isset($definition['inheritance']['type']) && $definition['inheritance']['type'] != 'class_table') {
            array_unshift($ret, '    parent::setUp();');
        }

        // If we have some code for the function then lets define it and return it
        if (count($ret)) {
            array_unshift($ret,
                '  public function setUp()',
                '  {',
                '    $table = $this->getTable();'
            );
            $ret[] = '  }';
        }
        return $ret;
    }

    private function buildColumns(array $columns)
    {
        $result = array();
        foreach ($columns as $name => $column) {
            $columnName = isset($column['name']) ? $column['name']:$name;
            $build = "    ".'$table->setColumn(\'' . $columnName . '\', \'' . $column['type'] . '\'';

            if ($column['length']) {
                if (is_numeric($column['length']))
                    $build .= ', ' . $column['length'];
                else
                    $build .= ', array(' . $column['length'] . ')';
            } else {
                $build .= ', null';
            }

            $options = $column;

            // Remove name, alltypes, ntype. They are not needed in options array
            unset($options['name']);
            unset($options['alltypes']);
            unset($options['ntype']);

            // Remove notnull => true if the column is primary
            // Primary columns are implied to be notnull in IPF_ORM
            if (isset($options['primary']) && $options['primary'] == true && (isset($options['notnull']) && $options['notnull'] == true)) {
                unset($options['notnull']);
            }

            // Remove default if the value is 0 and the column is a primary key
            // IPF_ORM defaults to 0 if it is a primary key
            if (isset($options['primary']) && $options['primary'] == true && (isset($options['default']) && $options['default'] == 0)) {
                unset($options['default']);
            }

            // These can be removed if they are empty. They all default to a false/0/null value anyways
            $remove = array('fixed', 'primary', 'notnull', 'autoincrement', 'unsigned');
            foreach ($remove as $key) {
                if (isset($options[$key]) && empty($options[$key])) {
                    unset($options[$key]);
                }
            }

            // Remove null and empty array values
            foreach ($options as $key => $value) {
                if (is_null($value) || (is_array($value) && empty($value))) {
                    unset($options[$key]);
                }
            }

            if (is_array($options) && !empty($options)) {
                $build .= ', ' . self::varExport($options);
            }

            $build .= ');';

            $result[] = $build;
        }

        return implode(PHP_EOL, $result);
    }

    private function buildTemplates(array $templates, array &$build)
    {
        foreach ($templates as $name => $options) {
            if (is_array($options) && !empty($options)) {
                $build[] = "    \$table->addTemplate('$name', " . self::varExport($options) . ");";
            } elseif (isset($templates[0])) {
                $build[] = "    \$table->addTemplate('$options');";
            } else {
                $build[] = "    \$table->addTemplate('$name');";
            }
        }
    }

    private function buildActAs($actAs, array &$build)
    {
        // rewrite special case of actAs: [Behavior] which gave [0] => Behavior
        if (is_array($actAs) && isset($actAs[0]) && !is_array($actAs[0])) {
            $actAs = array_flip($actAs);
        }

        // rewrite special case of actAs: Behavior
        if (!is_array($actAs))
            $actAs = array($actAs => '');

        foreach ($actAs as $template => $options) {
            // find class matching $name
            if (class_exists('IPF_ORM_Template_'.$template, true))
                $classname = 'IPF_ORM_Template_'.$template;
            else
                $classname = $template;

            if (is_array($options))
                $options = self::varExport($options);
            else
                $options = '';

            $build[] = "    \$table->addTemplate(new $classname($options));";
        }
    }

    private function buildAttributes(array $attributes)
    {
        $build = PHP_EOL;
        foreach ($attributes as $key => $value) {

            if (is_bool($value)) {
                $values = $value ? 'true':'false';
            } else {
                if (!is_array($value))
                    $value = array($value);

                $values = '';
                foreach ($value as $attr) {
                    $values .= "IPF_ORM::" . strtoupper($key) . "_" . strtoupper($attr) . ' ^ ';
                }

                // Trim last ^
                $values = substr($values, 0, strlen($values) - 3);
            }

            $build .= "    \$table->setAttribute(IPF_ORM::ATTR_" . strtoupper($key) . ", " . $values . ");" . PHP_EOL;
        }

        return $build;
    }

    private function buildOptions(array $options)
    {
        $build = '';
        foreach ($options as $name => $value) {
            $build .= "    \$table->setOption('$name', " . self::varExport($value) . ");" . PHP_EOL;
        }
        return $build;
    }

    public function buildRecord(array $definition, $targetPath)
    {
        if (!isset($definition['className']))
            throw new IPF_ORM_Exception('Missing class name.');

        $this->writeBaseDefinition($definition, $targetPath);
        $this->writeModelDefinition($definition, $targetPath);
    }

    private function writeBaseDefinition(array $definition, $targetPath)
    {
        $code = array(
            '<?php',
            '',
            '/**',
            ' * This class has been auto-generated by the IPF_ORM Framework.',
            ' * Changes to this file may cause incorrect behavior',
            ' * and will be lost if the code is regenerated.',
            ' */',
            '',
        );

        if (isset($definition['connection']) && $definition['connection']) {
            $code[] = '// Connection Component Binding';
            $code[] = "IPF_ORM_Manager::getInstance()->bindComponent('" . $definition['connectionClassName'] . "', '" . $definition['connection'] . "');";
            $code[] = '';
        }

        $code[] = 'abstract class '.$this->_baseClassPrefix.$definition['className'].' extends IPF_ORM_Record';
        $code[] = '{';
        $code[] = $this->buildTableDefinition($definition);
        $code[] = '';
        $code   = array_merge($code, $this->buildSetUp($definition));
        $code[] = '';
        $code   = array_merge($code, $this->buildShortcuts($definition));
        $code[] = '}';

        $fileName = $this->_baseClassPrefix . $definition['className'] . '.php';
        $writePath = $targetPath . DIRECTORY_SEPARATOR . $this->_baseClassesDirectory;
        IPF_Utils::makeDirectories($writePath);
        $writePath .= DIRECTORY_SEPARATOR . $fileName;

        if (file_put_contents($writePath, implode(PHP_EOL, $code)) === false)
            throw new IPF_ORM_Exception("Couldn't write file " . $writePath);
    }

    private function buildShortcuts(array $definition)
    {
        return array(
            '  public static function table()',
            '  {',
            '    return IPF_ORM::getTable(\''.$definition['className'].'\');',
            '  }',
            '',
            '  public static function query($alias=\'\')',
            '  {',
            '    return IPF_ORM::getTable(\''.$definition['className'].'\')->createQuery($alias);',
            '  }',
        );
    }

    private function writeModelDefinition(array $definition, $targetPath)
    {
        $className = $definition['className'];
        $adminClassName = $className.'Admin';

        $writePath = $targetPath . DIRECTORY_SEPARATOR . $className . '.php';
        if (file_exists($writePath))
            return;

        $code = array(
            '<?php',
            '',
            sprintf('class %s extends %s%s', $className, $this->_baseClassPrefix, $className),
            '{',
            '}',
            '',
            '/*',
            'class '.$adminClassName.' extends IPF_Admin_Model',
            '{',
            '}',
            '',
            'IPF_Admin_Model::register(\''.$className.'\', \''.$adminClassName.'\');',
            '*/',
            '',
        );

        IPF_Utils::makeDirectories($targetPath);
        if (file_put_contents($writePath, implode(PHP_EOL, $code)) === false)
            throw new IPF_ORM_Exception("Couldn't write file " . $writePath);
    }
}

